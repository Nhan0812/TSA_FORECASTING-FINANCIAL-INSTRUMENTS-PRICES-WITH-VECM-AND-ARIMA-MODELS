plot(serial.test(Data.vec5.asVAR))
Data.vec5.asVAR %>%
residuals() %>%
as_tibble() %>%
ggplot(aes(`resids of x1`)) +
geom_histogram(aes(y =..density..),
colour = "black",
fill = "pink") +
stat_function(fun = dnorm,
args = list(mean = mean(residuals(Data.vec5.asVAR)[, 1]),
sd = sd(residuals(Data.vec5.asVAR)[, 1]))) +
theme_bw() +
labs(
title = "Density of x1 residuals",
y = "", x = "",
caption = "source: own calculations"
)
Data.vec5.asVAR %>%
residuals() %>%
as_tibble() %>%
ggplot(aes(`resids of x2`)) +
geom_histogram(aes(y =..density..),
colour = "black",
fill = "pink") +
stat_function(fun = dnorm,
args = list(mean = mean(residuals(Data.vec5.asVAR)[, 2]),
sd = sd(residuals(Data.vec5.asVAR)[, 2]))) +
theme_bw() +
labs(
title = "Density of x2 residuals",
y = "", x = "",
caption = "source: own calculations"
)
normality.test(Data.vec5.asVAR)
Data.vec5.fore <-
predict(
vec2var(
johan.test.eigen,
r = 1),     # no of cointegrating vectors
n.ahead = 30, # forecast horizon
ci = 0.95)    # confidence level for intervals
summary(Data.vec5.fore)
Data.vec5.fore$fcst$x1
Data.vec5.fore$fcst$x2
tail(index(out_of_sample), 30)
x1_forecast <- xts(Data.vec5.fore$fcst$x1[,-4],
# we exclude the last column with CI
tail(index(out_of_sample), 30))
names(x1_forecast) <- c("x1_fore", "x1_lower", "x1_upper")
x2_forecast <- xts(Data.vec5.fore$fcst$x2[, -4],
# we exclude the last column with CI
tail(index(out_of_sample), 30))
names(x2_forecast) <- c("x2_fore", "x2_lower", "x2_upper")
Data.fore <- merge(out_of_sample[,1:2],
x1_forecast,
x2_forecast)
tail(Data.fore,40)
plot(Data.fore ["2020-11/", c("x1", "x1_fore", "x1_lower", "x1_upper")],
major.ticks = "years",
grid.ticks.on = "years",
grid.ticks.lty = 3,
main = "30 day forecast of x1",
col = c("black", "blue", "red", "red"))
plot(Data.fore ["2020-11/", c("x2", "x2_fore", "x2_lower", "x2_upper")],
major.ticks = "years",
grid.ticks.on = "years",
grid.ticks.lty = 3,
main = "30 day forecast of x2",
col = c("black", "blue", "red", "red"))
Data.fore2 <- Data.fore[,-30]
Data.fore2$mae.x1   <-  abs(Data.fore2$x1 - Data.fore2$x1_fore)
Data.fore2$mse.x1   <-  (Data.fore2$x1 - Data.fore2$x1_fore)^2
Data.fore2$mape.x1  <-  abs(Data.fore2$x1 - Data.fore2$x1_fore)/Data.fore2$x1
Data.fore2$amape.x1 <-  abs(Data.fore2$x1 - Data.fore2$x1_fore)/(Data.fore2$x1 + Data.fore2$x1_fore)
Data.fore2$mae.x2   <-  abs(Data.fore2$x2 - Data.fore2$x2_fore)
Data.fore2$mse.x2   <-  (Data.fore2$x2 - Data.fore2$x2_fore)^2
Data.fore2$mape.x2  <-  abs(Data.fore2$x2 - Data.fore2$x2_fore)/Data.fore2$x2
Data.fore2$amape.x2 <-  abs(Data.fore2$x2 - Data.fore2$x2_fore)/(Data.fore2$x2 + Data.fore2$x2_fore)
VECM_x1 <- colMeans(Data.fore2[, c("mae.x1",
"mse.x1",
"mape.x1",
"amape.x1")], na.rm = TRUE)
VECM_x2 <- colMeans(Data.fore2[, c("mae.x2",
"mse.x2",
"mape.x2",
"amape.x2")], na.rm = TRUE)
result <- rbind(ARIMA_x1,VECM_x1, ARIMA_x2,VECM_x2)
result %>%
knitr::kable(digits = 4) %>%
kableExtra::kable_styling(full_width = F,
bootstrap_options = c("striped",
"hover",
"condensed"))
plot(Data,
main = "Graph for 10 Time Series",
major.ticks = "years",
grid.ticks.on = "years",
grid.ticks.lty = 3,
legend.loc = "bottomleft",
type="l")
plot(Data,
main = "Graph for 10 Time Series",
major.ticks = "years",
grid.ticks.on = "years",
legend.loc = "bottomleft",
multi.panel = TRUE,
yaxis.same = FALSE,
type="l")
Data$dx1 <- diff.xts(Data$x1)
Data$dx2 <- diff.xts(Data$x2)
plot(Data[, 1:2],
col = c("black", "blue"),
major.ticks = "years",
grid.ticks.on = "years",
grid.ticks.lty = 2,
main = "Time Series X1 & X2",
legend.loc = "topright")
testdf(variable = Data$x1,
max.augmentations = 3)
testdf(variable = Data$dx1,
max.augmentations = 3)
testdf(variable = Data$x2,
max.augmentations = 3)
testdf(variable = Data$dx2,
max.augmentations = 3)
model.coint <- lm(x1 ~ x2, data = Data)
summary(model.coint)
testdf(variable = residuals(model.coint), max.augmentations = 3)
par(mfrow = c(2, 1))
acf(Data$dx1,
lag.max = 36, # max lag for ACF
ylim = c(-0.1, 0.1),   # limits for the y axis - we give c(min, max)
lwd = 5,
col = "dark green",
na.action = na.pass)   # do not stop if there are missing values in the data
pacf(Data$dx1,
lag.max = 36,
lwd = 5, col = "dark green",
na.action = na.pass)
par(mfrow = c(1, 1)) # restore the original single panel
arima510 <- Arima(Data$x1,  # variable
order = c(5, 1, 0)  # (p,d,q) parameters
)
arima313 <- Arima(Data$x1,  # variable
order = c(3, 1, 3)  # (p,d,q) parameters
)
coeftest(arima510)
summary(arima510)
arima510_2 <- Arima(Data$x1,  # variable
order = c(5, 1, 0),  # (p,d,q) parameters
include.constant = TRUE)  # including a constant
coeftest(arima510_2)
plot(resid(arima510))
plot(resid(arima313), col = "royalblue3")
plot_ACF_PACF_resids(arima510)
Box.test(resid(arima510), type = "Ljung-Box", lag = 10)
Box.test(resid(arima510), type = "Ljung-Box", lag = 15)
Box.test(resid(arima510), type = "Ljung-Box", lag = 20)
Box.test(resid(arima510), type = "Ljung-Box", lag = 25)
Box.test(resid(arima313), type = "Ljung-Box", lag = 10)
Box.test(resid(arima313), type = "Ljung-Box", lag = 15)
Box.test(resid(arima313), type = "Ljung-Box", lag = 20)
Box.test(resid(arima313), type = "Ljung-Box", lag = 25)
bj_pvalues = c()
for(i in c(1:100)){
bj = Box.test(resid(arima313), type = "Ljung-Box", lag = i)
bj_pvalues = append(bj_pvalues,bj$p.value)
}
plot(bj_pvalues, type='l')
abline(h = 0.05, col='red')
arima511 <- Arima(Data$x1,  # variable
order = c(5, 1, 1),  # (p,d,q) parameters
include.constant = TRUE)  # including a constant
coeftest(arima511)
arima410 <- Arima(Data$x1,  # variable
order = c(4, 1, 0),  # (p,d,q) parameters
include.constant = TRUE)  # including a constant
coeftest(arima410)
arima310 <- Arima(Data$x1,  # variable
order = c(3, 1, 0),  # (p,d,q) parameters
include.constant = TRUE)  # including a constant
coeftest(arima310)
AIC(arima510,arima510_2, arima511, arima410, arima310, arima313)
BIC(arima510, arima510_2, arima511, arima410, arima310, arima313)
arima.best.AIC <-
auto.arima(Data$x1,
d = 1,             # parameter d of ARIMA model
max.p = 6,         # Maximum value of p
max.q = 6,         # Maximum value of q
max.order = 12,    # maximum p+q
start.p = 1,       # Starting value of p in stepwise procedure
start.q = 1,       # Starting value of q in stepwise procedure
ic = "aic",        # Information criterion to be used in model selection.
stepwise = FALSE,  # if FALSE considers all models
allowdrift = TRUE, # include a constant
trace = TRUE)      # show summary of all models considered
arima412 <- Arima(Data$x1,  # variable
order = c(4, 1, 2),  # (p,d,q) parameters
include.constant = TRUE)  # including a constant
coeftest(arima412)
AIC(arima313,arima412)
BIC(arima313,arima412)
arima.best.BIC <-
auto.arima(Data$x1,
d = 1,             # parameter d of ARIMA model
max.p = 6,         # Maximum value of p
max.q = 6,         # Maximum value of q
max.order = 12,    # maximum p+q
start.p = 1,       # Starting value of p in stepwise procedure
start.q = 1,       # Starting value of q in stepwise procedure
ic = "bic",        # Information criterion to be used in model selection.
stepwise = FALSE,  # if FALSE considers all models
allowdrift = TRUE, # include a constant
trace = TRUE)      # show summary of all models considered
arima312 <- Arima(Data$x1,  # variable
order = c(3, 1, 2),  # (p,d,q) parameters
include.constant = TRUE)  # including a constant
coeftest(arima312)
AIC(arima313,arima412,arima312)
BIC(arima313,arima412,arima312)
par(mfrow = c(2, 1))
acf(Data$dx2,
lag.max = 36, # max lag for ACF
ylim = c(-0.1, 0.1),   # limits for the y axis - we give c(min, max)
lwd = 5,
col = "dark green",
na.action = na.pass)   # do not stop if there are missing values in the data
pacf(Data$dx2,
lag.max = 36,
lwd = 5, col = "dark green",
na.action = na.pass)
par(mfrow = c(1, 1)) # restore the original single panel
arima510_x2 <- Arima(Data$x2,  # variable
order = c(5, 1, 0)  # (p,d,q) parameters
)
coeftest(arima510_x2)
summary(arima510_x2)
arima510_2_x2 <- Arima(Data$x2,  # variable
order = c(5, 1, 0),  # (p,d,q) parameters
include.constant = TRUE)  # including a constant
coeftest(arima510_2_x2)
plot(resid(arima510_x2))
Box.test(resid(arima510_x2), type = "Ljung-Box", lag = 10)
Box.test(resid(arima510_x2), type = "Ljung-Box", lag = 15)
Box.test(resid(arima510_x2), type = "Ljung-Box", lag = 20)
Box.test(resid(arima510_x2), type = "Ljung-Box", lag = 25)
bj_pvalues = c()
for(i in c(1:100)){
bj = Box.test(resid(arima510_x2), type = "Ljung-Box", lag = i)
bj_pvalues = append(bj_pvalues,bj$p.value)
}
plot(bj_pvalues, type='l')
abline(h=0.05, col='red')
arima511_x2 <- Arima(Data$x2,  # variable
order = c(5, 1, 1),  # (p,d,q) parameters
include.constant = TRUE)  # including a constant
coeftest(arima511_x2)
arima410_x2 <- Arima(Data$x2,  # variable
order = c(4, 1, 0),  # (p,d,q) parameters
include.constant = TRUE)  # including a constant
coeftest(arima410_x2)
arima310_x2 <- Arima(Data$x2,  # variable
order = c(3, 1, 0),  # (p,d,q) parameters
include.constant = TRUE)  # including a constant
coeftest(arima310_x2)
AIC(arima510_x2,arima510_2_x2, arima511_x2, arima410_x2, arima310_x2)
BIC(arima510_x2, arima510_2_x2, arima511_x2, arima410_x2, arima310_x2)
arima.best.AIC <-
auto.arima(Data$x2,
d = 1,             # parameter d of ARIMA model
max.p = 6,         # Maximum value of p
max.q = 6,         # Maximum value of q
max.order = 12,    # maximum p+q
start.p = 1,       # Starting value of p in stepwise procedure
start.q = 1,       # Starting value of q in stepwise procedure
ic = "aic",        # Information criterion to be used in model selection.
stepwise = FALSE,  # if FALSE considers all models
allowdrift = TRUE, # include a constant
trace = TRUE)      # show summary of all models considered
arima313_x2 <- Arima(Data$x2,  # variable
order = c(3, 1, 3),  # (p,d,q) parameters
include.constant = TRUE)  # including a constant
AIC(arima510_x2,arima313_x2)
BIC(arima510_x2,arima313_x2)
arima.best.BIC <-
auto.arima(Data$x2,
d = 1,             # parameter d of ARIMA model
max.p = 6,         # Maximum value of p
max.q = 6,         # Maximum value of q
max.order = 12,    # maximum p+q
start.p = 1,       # Starting value of p in stepwise procedure
start.q = 1,       # Starting value of q in stepwise procedure
ic = "bic",        # Information criterion to be used in model selection.
stepwise = FALSE,  # if FALSE considers all models
allowdrift = TRUE, # include a constant
trace = TRUE)      # show summary of all models considered
arima312_x2 <- Arima(Data$x2,  # variable
order = c(3, 1, 2),  # (p,d,q) parameters
include.constant = TRUE)  # including a constant
AIC(arima510_x2,arima313_x2, arima312_x2)
BIC(arima510_x2,arima313_x2,arima312_x2 )
out_of_sample <-read.csv("Out_of_sample.csv",header = TRUE, dec = ".")
class(out_of_sample)
out_of_sample$X <- as.Date(out_of_sample$X,
format = "%d-%m-%y")
out_of_sample <- xts(out_of_sample[,-1], out_of_sample$X)
oos_x1 <- out_of_sample$x1
oos_x1
tail(Data, 12)
forecasts_x1 <- forecast(arima313, # model for prediction
h = 30) # how many periods outside the sample
forecasts_x1
forecasts_x1$mean
class(forecasts_x1$mean)
forecasts_x1$lower
forecasts_x1$upper
forecasts_x1_data <- data.frame(f_mean = as.numeric(forecasts_x1$mean),
f_lower = as.numeric(forecasts_x1$lower[, 2]),
f_upper = as.numeric(forecasts_x1$upper[, 2]))
head(forecasts_x1_data,30)
Data_x1 <- rbind(Data[, "x1"], oos_x1)
tail(Data_x1, n = 40)
forecasts_x1_xts <- xts(forecasts_x1_data,
order.by = index(oos_x1))
forecasts_x1_xts
Data_x1_combined <- merge(Data_x1, forecasts_x1_xts)
head(Data_x1_combined)
tail(Data_x1_combined,40)
plot(Data_x1_combined [, c("x1", "f_mean", "f_lower", "f_upper")],
major.ticks = "years",
grid.ticks.on = "years",
grid.ticks.lty = 3,
main = "30 day forecast of x1",
col = c("black", "blue", "red", "red"))
plot(Data_x1_combined ["2020-11/", c("x1", "f_mean", "f_lower", "f_upper")],
major.ticks = "years",
grid.ticks.on = "years",
grid.ticks.lty = 3,
main = "30 day forecast of x1",
col = c("black", "blue", "red", "red"))
Data_x1_Eva <- tail(Data_x1_combined, 30)
Data_x1_Eva
Data_x1_Eva$mae   <-  abs(Data_x1_Eva$x1 - Data_x1_Eva$f_mean)
Data_x1_Eva$mse   <-  (Data_x1_Eva$x1 - Data_x1_Eva$f_mean) ^ 2
Data_x1_Eva$mape  <-  abs((Data_x1_Eva$x1 - Data_x1_Eva$f_mean)/Data_x1_Eva$x1)
Data_x1_Eva$amape <-  abs((Data_x1_Eva$x1 - Data_x1_Eva$f_mean)/(Data_x1_Eva$x1 + Data_x1_Eva$f_mean))
Data_x1_Eva
ARIMA_x1 <- colMeans(Data_x1_Eva[, c("mae", "mse", "mape", "amape")])
apply(Data_x1_Eva[, c("mae", "mse", "mape", "amape")], 2, FUN = median)
oos_x2 <- out_of_sample$x2
oos_x2
tail(Data, 12)
forecasts_x2 <- forecast(arima510_x2, # model for prediction
h = 30) # how many periods outside the sample
forecasts_x2
forecasts_x2$mean
class(forecasts_x2$mean)
forecasts_x2$lower
forecasts_x2$upper
forecasts_x2_data <- data.frame(f_mean = as.numeric(forecasts_x2$mean),
f_lower = as.numeric(forecasts_x2$lower[, 2]),
f_upper = as.numeric(forecasts_x2$upper[, 2]))
head(forecasts_x2_data,30)
Data_x2 <- rbind(Data[, "x2"], oos_x2)
tail(Data_x2, n = 40)
forecasts_x2_xts <- xts(forecasts_x2_data,
order.by = index(oos_x2))
forecasts_x2_xts
Data_x2_combined <- merge(Data_x2, forecasts_x2_xts)
head(Data_x2_combined)
tail(Data_x2_combined,40)
plot(Data_x2_combined ["2020-11/", c("x2", "f_mean", "f_lower", "f_upper")],
major.ticks = "years",
grid.ticks.on = "years",
grid.ticks.lty = 3,
main = "30 day forecast of x2",
col = c("black", "blue", "red", "red"))
Data_x2_Eva <- tail(Data_x2_combined, 30)
Data_x2_Eva
Data_x2_Eva$mae   <-  abs(Data_x2_Eva$x2 - Data_x2_Eva$f_mean)
Data_x2_Eva$mse   <-  (Data_x2_Eva$x2 - Data_x2_Eva$f_mean) ^ 2
Data_x2_Eva$mape  <-  abs((Data_x2_Eva$x2 - Data_x2_Eva$f_mean)/Data_x2_Eva$x2)
Data_x2_Eva$amape <-  abs((Data_x2_Eva$x2 - Data_x2_Eva$f_mean)/(Data_x2_Eva$x2 + Data_x2_Eva$f_mean))
Data_x2_Eva
ARIMA_x2 <- colMeans(Data_x2_Eva[, c("mae", "mse", "mape", "amape")])
apply(Data_x2_Eva[, c("mae", "mse", "mape", "amape")], 2, FUN = median)
johan.test.trace <-
ca.jo(Data[,1:2], # data
ecdet = "const", # "none" for no intercept in cointegrating equation,
# "const" for constant term in cointegrating equation and
# "trend" for trend variable in cointegrating equation
type = "trace",  # type of the test: trace or eigen
K = 5           # lag order of the series (levels) in the VAR
)
summary(johan.test.trace)
cbind(summary(johan.test.trace)@teststat,
summary(johan.test.trace)@cval)
summary(johan.test.trace)@V
summary(johan.test.trace)@W
johan.test.eigen <-
ca.jo(Data[,1:2], # data
ecdet = "const", # "none" for no intercept in cointegrating equation,
# "const" for constant term in cointegrating equation and
# "trend" for trend variable in cointegrating equation
type = "eigen",  # type of the test: trace or eigen
K = 5           # lag order of the series (levels) in the VAR
)
summary(johan.test.eigen)
Data.vec5 <- cajorls(johan.test.eigen, # defined specification
r = 1) # number of cointegrating vectors
summary(Data.vec5)
summary(Data.vec5$rlm)
Data.vec5$beta
Data.vec5.asVAR <- vec2var(johan.test.eigen, r = 1)
Data.vec5.asVAR
plot(irf(Data.vec5.asVAR, n.ahead = 36), ask = FALSE)
plot(fevd(Data.vec5.asVAR, n.ahead = 36), ask = FALSE)
head(residuals(Data.vec5.asVAR))
serial.test(Data.vec5.asVAR)
plot(serial.test(Data.vec5.asVAR))
Data.vec5.asVAR %>%
residuals() %>%
as_tibble() %>%
ggplot(aes(`resids of x1`)) +
geom_histogram(aes(y =..density..),
colour = "black",
fill = "pink") +
stat_function(fun = dnorm,
args = list(mean = mean(residuals(Data.vec5.asVAR)[, 1]),
sd = sd(residuals(Data.vec5.asVAR)[, 1]))) +
theme_bw() +
labs(
title = "Density of x1 residuals",
y = "", x = "",
caption = "source: own calculations"
)
Data.vec5.asVAR %>%
residuals() %>%
as_tibble() %>%
ggplot(aes(`resids of x2`)) +
geom_histogram(aes(y =..density..),
colour = "black",
fill = "pink") +
stat_function(fun = dnorm,
args = list(mean = mean(residuals(Data.vec5.asVAR)[, 2]),
sd = sd(residuals(Data.vec5.asVAR)[, 2]))) +
theme_bw() +
labs(
title = "Density of x2 residuals",
y = "", x = "",
caption = "source: own calculations"
)
normality.test(Data.vec5.asVAR)
Data.vec5.fore <-
predict(
vec2var(
johan.test.eigen,
r = 1),     # no of cointegrating vectors
n.ahead = 30, # forecast horizon
ci = 0.95)    # confidence level for intervals
summary(Data.vec5.fore)
Data.vec5.fore$fcst$x1
Data.vec5.fore$fcst$x2
tail(index(out_of_sample), 30)
x1_forecast <- xts(Data.vec5.fore$fcst$x1[,-4],
# we exclude the last column with CI
tail(index(out_of_sample), 30))
names(x1_forecast) <- c("x1_fore", "x1_lower", "x1_upper")
x2_forecast <- xts(Data.vec5.fore$fcst$x2[, -4],
# we exclude the last column with CI
tail(index(out_of_sample), 30))
names(x2_forecast) <- c("x2_fore", "x2_lower", "x2_upper")
Data.fore <- merge(out_of_sample[,1:2],
x1_forecast,
x2_forecast)
tail(Data.fore,40)
plot(Data.fore ["2020-11/", c("x1", "x1_fore", "x1_lower", "x1_upper")],
major.ticks = "years",
grid.ticks.on = "years",
grid.ticks.lty = 3,
main = "30 day forecast of x1",
col = c("black", "blue", "red", "red"))
plot(Data.fore ["2020-11/", c("x2", "x2_fore", "x2_lower", "x2_upper")],
major.ticks = "years",
grid.ticks.on = "years",
grid.ticks.lty = 3,
main = "30 day forecast of x2",
col = c("black", "blue", "red", "red"))
Data.fore2 <- Data.fore[,-30]
Data.fore2$mae.x1   <-  abs(Data.fore2$x1 - Data.fore2$x1_fore)
Data.fore2$mse.x1   <-  (Data.fore2$x1 - Data.fore2$x1_fore)^2
Data.fore2$mape.x1  <-  abs(Data.fore2$x1 - Data.fore2$x1_fore)/Data.fore2$x1
Data.fore2$amape.x1 <-  abs(Data.fore2$x1 - Data.fore2$x1_fore)/(Data.fore2$x1 + Data.fore2$x1_fore)
Data.fore2$mae.x2   <-  abs(Data.fore2$x2 - Data.fore2$x2_fore)
Data.fore2$mse.x2   <-  (Data.fore2$x2 - Data.fore2$x2_fore)^2
Data.fore2$mape.x2  <-  abs(Data.fore2$x2 - Data.fore2$x2_fore)/Data.fore2$x2
Data.fore2$amape.x2 <-  abs(Data.fore2$x2 - Data.fore2$x2_fore)/(Data.fore2$x2 + Data.fore2$x2_fore)
VECM_x1 <- colMeans(Data.fore2[, c("mae.x1",
"mse.x1",
"mape.x1",
"amape.x1")], na.rm = TRUE)
VECM_x2 <- colMeans(Data.fore2[, c("mae.x2",
"mse.x2",
"mape.x2",
"amape.x2")], na.rm = TRUE)
result <- rbind(ARIMA_x1,VECM_x1, ARIMA_x2,VECM_x2)
result %>%
knitr::kable(digits = 4) %>%
kableExtra::kable_styling(full_width = F,
bootstrap_options = c("striped",
"hover",
"condensed"))
